

library(tidyverse)
library(poolfstat)

count_file <- function(x){
    paste0("~/_data/_tany-time/snape/count_masked_time/", x)
}

Rcpp::sourceCpp("_R/snape-helpers.cpp")  # `count_alleles` function

.n_threads <- max(1L, parallel::detectCores()-2L)


samp_df <- read_csv("_data/full-sample-info.csv", col_types = "cDccidd")

pools <- read_lines(count_file("count_masked_time.names.gz"))
n_haps <- pools |>
    set_names() |>
    map_int(\(x) 2L * samp_df$n_adults[samp_df$biotech_id == x]) |>
    as.list()

#' Remove very low coverage and non-biallelic SNPs, read into pooldata object.
#' Takes ~9 sec with 6 threads
pool_dat <- count_file("count_masked_time_noblanks.sync.gz") |>
    popsync2pooldata(poolsizes = n_haps, poolnames = pools,
                     nthreads = .n_threads)

#' Remove SNPs near fixation because
#' "... nearly fixed markers (e.g., π < 0.05 or π > 0.95) are not expected to be
#' associated with any covariate, even if they are adjacent to strongly
#' associated SNPs, which can severely degrade the detection of clustered
#' signals." (BayPass v1.31 manual)
#'
# Create a logical vector for which SNPs aren't near fixation:
avg_ref_probs <- apply(pool_dat@refallele.readcount / pool_dat@readcoverage,
                       1, mean)
poly_snps <- avg_ref_probs > 0.1 & avg_ref_probs < 0.9

# Now updating fields:
pool_dat@nsnp <- sum(poly_snps)
pool_dat@refallele.readcount <- pool_dat@refallele.readcount[poly_snps,]
pool_dat@readcoverage <- pool_dat@readcoverage[poly_snps,]
pool_dat@snp.info <- pool_dat@snp.info[poly_snps,]
print(pool_dat@nsnp)
# [1] 433360

#' Now convert to format for baypass:
pooldata2genobaypass(pool_dat, "~/_data/_baypass", "THINNED__tany_time",
                     subsamplesize = pool_dat@nsnp %/% 5L)
# 5 sub-samples of ca. 86672 SNPs will be generated by tacking one SNP every 5


#' Lastly, write a file for the covariate, log(density + 1):
pop_df <- read_csv("_data/tany-abundances.csv", col_types = "ifdd") |>
    mutate(gen = as.integer(gen))

pools |>
    str_remove_all("^SN-|_S.?.?$") |>
    str_split("-") |>
    map(as.integer) |>
    set_names(pools) |>
    imap(\(x, p) {
        yr <- ifelse(x[2] < 77, 2000L + x[2], 1900L + x[2])
        gen <- x[1]
        tibble(pool = p, logN = pop_df$logN[pop_df$gen == gen & pop_df$year == yr])
    }) |>
    list_rbind() |>
    # Make it the same order as `pools`:
    arrange(match(pool, pools)) |>
    # Now extract just `logN` and write to file:
    getElement("logN") |>
    round(4) |>
    paste(collapse = " ") |>
    write_lines(file = "~/_data/_baypass/log_n.txt")



